# -*- coding: utf-8 -*-
"""pertemuan 7 DAA

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rIIygE0scuD7eUYF1dxEKxnPIXn8mYPs
"""

#SLIDE9
#MATRIKS

mat1 = [
    [7, 0],
    [4, 6],
]

mat2 = [
    [3, 0],
    [5, 2],
]

mat3 = []

for x in range(0, len(mat1)):
  row = []
  for y in range(0, len(mat1[0])):
    total = 0
    for z in range(0, len(mat1)):
      total = total + (mat1[x][z] * mat2[z][y])
    row.append(total)
  mat3.append(row)

for x in range(0, len(mat3)):
  for y in range(0, len(mat3[0])):
    print(mat3[x][y], end= ' ')
  print()

mat1 = [
    [7, 3],
    [2, 1],
]

mat2 = [
    [5, 4],
    [6, 3],
]

mat3 = []

for x in range (0, len(mat1)):
    row = []
    for y in range(0, len(mat1[0])):
        total = 0
        for z in range(0, len(mat1)):
            total = total + (mat1[x][z] * mat2[z][y])
        row.append(total)
    mat3.append(row)


for x in range(0, len(mat3)):
    for y in range(0, len(mat3[0])):
        print (mat3[x][y], end=' ')
    print()

#SLIDE11
#FAKTORIAL

def faktorial(n):
  if (n==1):
    return n
  return faktorial(n-1)*n

n = int(input("masukkan nilai n: ")) #input nilai
print(f"hasil dari {n}!", faktorial(n)) #output nilai

#SLIDE14
#NILAI MAKSIMAL

def nilai_maksimal(deret_bilangan):
  nilai_terbesar = deret_bilangan[0]

  for nilai in deret_bilangan:
    if nilai > nilai_terbesar:
      nilai_terbesar = nilai

  return nilai_terbesar

a = [3, 20, 100, -35, 50]

print(a)
print("Nilai terbesar: ", nilai_maksimal(a))

#NILAI MINIMAL

def nilai_minimal(deret_bilangan):
  nilai_terkecil = deret_bilangan[0]

  for nilai in deret_bilangan:
    if nilai < nilai_terkecil:
      nilai_terkecil = nilai

  return nilai_terkecil

a = [3, 20, 100, -35, 50]

print(a)
print("Nilai terkecil:", nilai_minimal(a))

#SLIDE17
#SEQUENTIAL

def sequentialsSearch(alist, item):
  pos = 0
  found = False

  while pos < len(alist) and not found:
    if alist[pos] == item:
      found = True
    else:
      pos = pos + 1
  return found

testlist = [1, 2, 32, 8, 17, 19, 42, 13, 0]
print(sequentialsSearch(testlist, 3))
print(sequentialsSearch(testlist, 2))

#SLIDE20
#BUBBLE SORT

def bubbleSort(alist):
  for passnum in range(len(alist)-1, 0, -1):
    for i in range(passnum):
      if alist[i] > alist[i+1]:
        temp = alist[i]
        alist[i] = alist[i+1]
        alist[i+1] = temp

alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]
bubbleSort(alist)
print(alist)

#SLIDE22
#UJI KEPRIMAAN

x = int(input('Input satu angka bulat: '))

angka_prima = True
if((x == 0) or (x == 1)):
  angka_prima = False
else:
 for i in range(2,(x//2)):
    if((x % i) == 0):
      angka_prima = False
      break

if(angka_prima):
  print(x,'adalah angka prima')
else:
  print(x,'bukan angka prima')

#SLIDE25
#MENGHITUNG POLYNOMIAL

def polynomial_py(a, x):
  result = 0
  # for every  in 0..len(a)-1
  for n, a_n in enumerate(a):
    # compute x^n
    x_power_n = 1
    for i in range(n):
      x_power_n *= x
    # add a_n * x^n to the final result
    result += a_n * x_power_n
  return result

a = [1, 2, 0, 3] # coefficients
x = 1.5
print(polynomial_py(a, x))

#SLIDE34
#Mathing Substring In String (34)
#Get matching substrings in string
#initializing sting
test_str = "GFG is good website";

# initializing potential substrings
test_list = ["GFG", "site", "CS", "Geeks", "Tutorial"]

# printing original string
print("The original string is : " + test_str)

#printing potential stings list
print("The original list is : " + str(test_list))

# using list comprehension
# Get matching substrings in string
res = [sub for sub in test_list if sub in test_str]

# printing result
print("The list of found substrings : " + str(res))

#SLIDE39
#Mencari pasangan titik jarak terdekat

from math import sqrt
from random import randint

titik = []
n = int(input('Masukkan jumlah titik yang ingin Anda cari jaraknya: '))
for i in range(0,n):
    titik.append([randint(0,100),randint(0,100)])
print('Titik:\n',titik)
def hitungjarak(lis):
    lisjarak = []
    for i in range (0,len(lis)-1):
        for j in range (i+1,len(lis)):
            jarak = sqrt((lis[i][0]-lis[j][0])**2 + (lis[i][1]-lis[j][1])**2)
            lisjarak.append(jarak)
            print('Titik: ',lis[i], 'Titik: ',lis[j],': ',jarak)
    return min(lisjarak)
print('Jarak terdekat:\n',hitungjarak(titik))

#SLIDE 78

#Find maximum value in linear search
def find_maximum(lst):
  max = None
  for el in lst:
    if max == None or el > max:
      max = el
  return max
test_scores = [88, 93, 75, 100, 80, 67, 71, 92, 90, 83]
print(find_maximum(test_scores)) #return 100

#Slide 79

#algoritma brute force : Bubble sort

def bubbleSort(alist):
  for passnum in range(len(alist)-1,0,-1):
    for i in range(passnum):
      if alist[i]>alist[i+1]:
        temp = alist[i]
        alist[i] = alist[i+1]
        alist[i+1] = temp

alist = [54,26,93,17,77,31,44,55,20]
bubbleSort(alist)
print(alist)

#SLIDE80
#algoritma brute force : selection sort

def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        imin = i
        for j in range(i + 1, n):
            if arr[j] < arr[imin]:
                imin = j
        if imin != i:
            temp = arr[i]
            arr[i] = arr[imin]
            arr[imin] = temp

# Contoh penggunaan:
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print("Hasil setelah Selection Sort:", arr)

#SLIDE 81

#Algoritma brute force : sequential search
def Sequential_search(dlist, item):

  pos = 0
  found = False

  while pos < len(dlist) and not found :
    if dlist[pos] == item:
      found = True
    else:
      pos = pos + 1

  return found, pos

print(Sequential_search([11,23,58,31,56,77,43,12,65,19],31))

#SLIDE 82
#LATIHAN SEQUENTIAL SEARCH
# Daftar deret a hingga h

deret = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

# String yang ingin dicari
cari_string = 'g'

def sequential_search(deret, target):
    for i in range(len(deret)):
        if deret[i] == target:
            return i  # Mengembalikan indeks pertama kali ditemukan
    return -1  # Mengembalikan -1 jika tidak ditemukan

# Mencari string 'g' dalam deret
hasil = sequential_search(deret, cari_string)

if hasil != -1:
    print(f"String '{cari_string}' ditemukan pada indeks ke-{hasil}.")
else:
    print(f"String '{cari_string}' tidak ditemukan dalam deret.")

#SLIDE 83
#Agoritma Brute force : pangkat

bilangan = int(input("masukkan bilangan : "))
pangkat = int(input("masukkan pangkat : "))

def hitung_pangkat(bilangan, pangkat):
  if pangkat > 1:
    return bilangan * hitung_pangkat(bilangan, pangkat -1)

  return bilangan

hasil = hitung_pangkat(bilangan, pangkat)
print(f'hasil = {hasil}')

#SLIDE 84
n = int(input('Masukkan nilai n: '))

def hitung_faktorial (n):
    if n > 2:
        return n * hitung_faktorial(n - 1)


    return 2

faktorial = hitung_faktorial(n)
print(f'{n}! = {faktorial}')

#SLIDE 85
#algoritma Brute Force: String matching

def string_match(string, sub_str):
    # Brute force string matching
    for i in range(len(string)-len(sub_str)+1):
        index = i # index Point to the 1 Three characters to be compared
        for j in range(len(sub_str)):
            if string[index] == sub_str[j]:
                index += 1
            else:
                break
            if index-i == len(sub_str):
                return i
    return -1

if __name__ == "__main__":
    print(string_match("adbcbdc","bdc"))

#SLIDE 86
#LATIHAN
# String yang akan dicari
string_utama = "123456789"

# String yang dicari
cari_string = "56"

if cari_string in string_utama:
    print(f"String '{cari_string}' ditemukan dalam string utama.")
else:
    print(f"String '{cari_string}' tidak ditemukan dalam string utama.")

#SLIDE92
#Algoritma Brute Force

import random
from itertools import permutations
alltours = permutations

def distance_tour(aTour):
    return sum(distance_points(aTour[i - 1], aTour[i])
        for i in range(len(aTour)))

aCity = complex
def distance_points(first, second):
    return abs(first - second)

def generate_cities (number_of_cities):
    seed=111;width=500;height=300
    random.seed((number_of_cities, seed))
    return frozenset(aCity(random.randint(1, width), random.randint(1,height))
        for c in range(number_of_cities))

#SLIDE93
# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt

def visualize_tour(tour, style='bo-'):
    if len(tour) > 1000: plt.figure(figzice=(15, 10))
    start = tour[0:1]
    visualize_segment(tour + start, style)
    visualize_segment(start, 'rD')
def visualize_segment (segment, style='bo-'):
        plt.plot([X(c) for c in segment], [Y(c) for c in segment], style, clip_on=False)
        plt.axis('scaled')
        plt.axis('off')

def X(city): "X axis"; return city.real

def Y(city): "Y axis"; return city.imag

from time import process_time
from collections import Counter
def tsp(algorithm, cities):
    t0 = process_time()
    tour = algorithm(cities)
    t1 = process_time()
    assert Counter(tour) == Counter(cities)
    visualize_tour(tour)
    print("{}:{} cities => tour lenght {:.0f}(in {:.3f} sec)".format(name(algorithm), len(tour), distance_tour(tour), t1-t0))

def name(algorithm): return algorithm._name_.replace('_tsp','')

#SLIDE94
from time import process_time
from collections import Counter
def tsp(algorithm, cities):
    t0 = process_time()
    tour = algorithm(cities)
    t1 = process_time()
    assert Counter(tour) == Counter(cities)
    visualize_tour(tour)
    print("{}:{} cities => tour lenght {:.0f}(in {:.3f} sec)".format(name(algorithm), len(tour), distance_tour(tour), t1-t0))

def name(algorithm): return algorithm._name_.replace('_tsp','')

#SLIDE95
#strategi algoritma brute force
def brute_force(cities):
    "Generate all possible tours of the cities and choose the shortest tour."
    return shortest_tour(alltours(cities))
def shortest_tour(tours): return min(tours, key=distance_tour)

tsp(brute_force, generate_cities(10))

